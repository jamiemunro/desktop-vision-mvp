<!doctype html><html><head>
<style>
  body { 
    margin: 0; 
    padding: 0; 
    font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
    background: #000;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .app {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100vw;
    height: 100vh;
  }

  .heart-button {
    width: 120px;
    height: 120px;
    border: none;
    border-radius: 50%;
    background: linear-gradient(45deg, #ff6b6b, #ee5a52);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3);
    position: relative;
    overflow: hidden;
  }

  .heart-button:hover {
    transform: scale(1.1);
    box-shadow: 0 12px 40px rgba(255, 107, 107, 0.5);
  }

  .heart-button:active {
    transform: scale(0.95);
  }

  .heart-button.recording {
    background: linear-gradient(45deg, #ff1744, #d50000);
    animation: pulse 2s infinite;
  }

  .heart-button.starting {
    background: linear-gradient(45deg, #ffab00, #ff6f00);
  }

  .heart {
    font-size: 48px;
    transition: all 0.3s ease;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
  }

  .recording .heart {
    animation: heartbeat 1.5s infinite;
  }

  @keyframes pulse {
    0% { box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3); }
    50% { box-shadow: 0 8px 32px rgba(255, 107, 107, 0.8); }
    100% { box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3); }
  }

  @keyframes heartbeat {
    0% { transform: scale(1); }
    14% { transform: scale(1.1); }
    28% { transform: scale(1); }
    42% { transform: scale(1.1); }
    70% { transform: scale(1); }
  }

  .heart-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 50%;
    background: linear-gradient(45deg, rgba(255,255,255,0.2), transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .heart-button:hover::before {
    opacity: 1;
  }
</style>
</head><body>
<div class="app">
  <button 
    class="heart-button" 
    id="toggle-recording"
  >
    <div class="heart">❤️</div>
  </button>
</div>

<script>
const toggleButton = document.getElementById('toggle-recording');
let isRecording = false;
let isStarting = false;

async function toggleRecording() {
  if (isStarting) return;
  
  isStarting = true;
  toggleButton.classList.add('starting');
  
  try {
    if (!isRecording) {
      await startAll();
    } else {
      await stopAll();
    }
  } catch (error) {
    console.error('Recording toggle failed:', error);
  } finally {
    isStarting = false;
    toggleButton.classList.remove('starting');
  }
}

async function startAll() {
  await startAudio();
  await startVision();
}

async function stopAll() {
  await stopVision();
  await stopAudio();
}

async function startVision() {
  try {
    const sources = await window.api.getSources();
    const sourceId = sources[0].id;
    const stream = await navigator.mediaDevices.getUserMedia({ 
      audio: false, 
      video: { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: sourceId } }
    });
    
    // Create hidden video element for capture
    const video = document.createElement('video');
    video.srcObject = stream;
    video.autoplay = true;
    video.muted = true;
    video.style.display = 'none';
    document.body.appendChild(video);
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    const captureInterval = setInterval(() => {
      if (!video.videoWidth) return;
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0);
      canvas.toBlob(async (blob) => {
        const arr = new Uint8Array(await blob.arrayBuffer());
        window.api.sendFrame({ timestamp: Date.now(), jpgBuffer: arr });
      }, 'image/jpeg', 0.6);
    }, 500);
    
    // Store for cleanup
    window.visionCleanup = () => {
      clearInterval(captureInterval);
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      if (video.parentNode) {
        video.parentNode.removeChild(video);
      }
    };
    
    isRecording = true;
    updateUI();
    
  } catch (error) {
    console.error('Vision start error:', error);
  }
}

async function stopVision() {
  try {
    if (window.visionCleanup) {
      window.visionCleanup();
      window.visionCleanup = null;
    }
    
    isRecording = false;
    updateUI();
    
  } catch (error) {
    console.error('Vision stop error:', error);
  }
}

async function startAudio() {
  try {
    const result = await window.api.startAudio();
    console.log('Audio started:', result);
  } catch (error) {
    console.error('Audio start error:', error);
  }
}

async function stopAudio() {
  try {
    const result = await window.api.stopAudio();
    console.log('Audio stopped:', result);
  } catch (error) {
    console.error('Audio stop error:', error);
  }
}

function updateUI() {
  if (isRecording) {
    toggleButton.classList.add('recording');
  } else {
    toggleButton.classList.remove('recording');
  }
}

// Event listeners
toggleButton.addEventListener('click', toggleRecording);

// Initialize
updateUI();
</script>
</body></html>